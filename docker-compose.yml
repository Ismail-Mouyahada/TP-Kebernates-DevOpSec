```yaml
version: "3.9"
services:
  tp-kebernates-devopsec:
    build:
      context: .
      dockerfile: Dockerfile  # Assurez-vous d'avoir un Dockerfile dans le répertoire courant
    ports:
      - "8080:8080" # Adaptez le port si nécessaire
    environment:
      - MY_ENV_VAR=my_value # Ajoutez vos variables d'environnement ici
      - ANOTHER_ENV_VAR=another_value
    volumes:
      - ./app:/app # Remplacez ./app par le chemin de votre application
    networks:
      - my-app-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"] # Remplacez par votre endpoint de healthcheck
      interval: 30s
      timeout: 10s
      retries: 3

networks:
  my-app-network:

volumes:
  # Ajoutez des volumes persistants ici si nécessaire, par exemple :
  # app-data:

```

**Explication:**

* **`version: "3.9"`:** Spécifie la version de Docker Compose.
* **`services:`:** Définit les services de l'application.
* **`tp-kebernates-devopsec:`:**  Nom du service principal.  Adaptez au besoin.
* **`build:`:**  Indique à Docker Compose de construire l'image à partir d'un `Dockerfile`. Assurez-vous que vous avez un fichier `Dockerfile` dans le même répertoire que ce fichier `docker-compose.yml`.  Ce fichier `Dockerfile` doit contenir les instructions pour construire l'image de votre application HCL.  Exemple simple (à adapter):

```dockerfile
FROM golang:1.20

WORKDIR /app

COPY go.mod ./
COPY go.sum ./
RUN go mod download

COPY . ./

RUN go build -o /app/tp-kebernates-devopsec

EXPOSE 8080

CMD ["./tp-kebernates-devopsec"]
```

* **`ports:`:** Mappe le port 8080 de l'hôte au port 8080 du conteneur.  Modifiez si nécessaire.
* **`environment:`:** Définit les variables d'environnement pour le conteneur.  Remplacez les exemples par vos propres variables.
* **`volumes:`:** Monte un volume pour que les modifications dans le répertoire `/app` sur votre hôte soient reflétées dans le conteneur.  Adaptez le chemin `./app` au chemin de votre application.
* **`networks:`:** Définit le réseau pour le service.  Ici, un réseau nommé `my-app-network` est créé.
* **`healthcheck:`:** Définit un contrôle de santé pour le service.  Il vérifie si l'endpoint `/health` répond avec un code 200. Adaptez l'URL selon votre application.
* **`networks:`:** Définit la section réseaux.
* **`volumes:`:**  Section pour définir les volumes nommés, utile pour la persistance de données (ici commenté car non requis dans votre cas).


**Avant d'exécuter:**

1. **Créer un `Dockerfile`:**  Créez un fichier `Dockerfile` dans le même répertoire que le `docker-compose.yml` avec les instructions pour construire votre image HCL.  L'exemple ci-dessus est pour une application Go, mais vous devrez l'adapter à votre langage (HCL nécessite un interpréteur).  Vous devrez peut-être utiliser une image de base avec Terraform ou autre outil HCL installé.
2. **Adapter les ports et les variables d'environnement:** Modifiez les ports et les variables d'environnement selon vos besoins.
3. **Adapter le healthcheck:** Modifiez l'endpoint de healthcheck pour correspondre à votre application.
4. **Adapter le chemin du volume:** Modifiez le chemin du volume si votre application n'est pas dans un répertoire nommé `app`.


Une fois ces étapes terminées, vous pouvez lancer votre application avec `docker-compose up -d`.


N'oubliez pas de remplacer les exemples par vos propres valeurs et configurations.  Ce fichier est un point de départ et doit être adapté à votre projet spécifique.
